# 操作系统

## 概念

用户角度上，操作系统是一个控制程序；管理应用程序；为应用程序提供服务；杀死应用程序。

能够资源管理；管理外设、资源分配

**Linux、Windows、Android的界面属于外壳Shell，而不是内核Kernel。**

操作系系统管理硬件（CPU、内存和磁盘以及网卡、声卡、显卡等等）

**CPU调度器**

**物理内存管理**

**虚拟内存管理**

**文件系统管理**

**中断处理与设备驱动**

### OS Kernel的特征

#### 并发

计算机系统中同时存在多个运行的程序，需要OS的调度（在一个时间段内可以有多个程序执行）

**并行**

（在一个时间点上有多个程序执行）一般需要有多个CPU核心，不然无法实现

#### 共享

"同时"共享、互斥共享

#### 虚拟

利用多道程序设计技术，让每个用户都觉得计算机专门为他服务

#### 异步

程序的执行不是一贯到底，而是走走停停，向前推进的速度不可预知，但只要运行环境相同，OS需要保证程序运行的结果也要相同

## 操作系统实例

**UNIX BSD家族**

**Linux家族**

**Windows家族**

## 操作系统

### 启动

![image-20241228112246889](C:\Users\29003\AppData\Roaming\Typora\typora-user-images\image-20241228112246889.png)

**CPU、Memory、I\O**

**DISK：**存放OS

**Bootloader：**将操作系统从硬盘加载到CPU（放在硬盘的第一个主引导扇区）

放在什么地方由BIOS决定 512字节

**BIOS：**基本I\O处理系统

**POST（加电自检）**寻找显卡和执行BIOS

**系统调用（来源于应用程序）**

1. 应用程序主动向操作协同发出服务请求
2. 异步或同步
3. 响应状态：等待和持续

**异常（来源于不良的应用程序）**

1. 非法指令或者其他坏的处理状态（如内存出错）
2. 同步产生
3. 响应状态：杀死或者重新执行，想不到的应用程序指令

**中断（来源于外设）**

1. 来自不同的硬件设备的计时器和网络中断
2. 异步产生
3. 响应状态：持续，对用户应用程序是透明的



为什么应用程序不能直接访问外设？

1. 在计算机运行中，内核是被信任的第三方（安全的服务）
2. 只有内核可以执行特权指令
3. 为了方便应用程序（为上层应用一个统一的简单的接口，屏蔽底层device的细节）

### 中断、异常和系统调用

#### 中断和异常的处理机制

##### 中断

1. 中断是外设的事件
2. 异常是内部CPU的事件
3. 中断和异常使CPU访问一些被中断和异常服务访问的功能

​	**硬件**

- 设置中断标记（CPU初始化）

  - 将内部、外部事件设置中断标记
  - 中断事件的ID

  中断事件的ID指程序访问的中断向量地址

​	**软件**

- 保存当前处理状态

- 中断服务程序处理
- 清除中断标记
- 恢复之前保存的处理状态

##### 异常

异常：异常编号

- 保存现场
- 异常处理
  - 杀死产生了异常的程序
  - 重新执行异常指令
- 恢复现场

##### **系统调用**

- 程序访问主要是通过高层次的API接口而不是直接进行系统调用
  - Win32API
  - POSIX API 用于UNIX，LINUX MacOS
  - Java API 用于Java虚拟机（JVM）

##### 跨越操作系统边界的开销

- 再执行时间上的开销超过程序调用
- 开销：
  - 建立中断/异常/系统调用号对应服务里程映射关系的初始化开销
  - 建立内核堆栈
  - 验证参数
  - 内核态映射到用户态的地址空间
    - 更新页面映射权限
  - 内核态独立地址空间

### 计算机体系结构/内存分层体系

**CPU存储**

![image-20241228144357048](C:\Users\29003\AppData\Roaming\Typora\typora-user-images\image-20241228144357048.png)

****

![image-20241228144451081](C:\Users\29003\AppData\Roaming\Typora\typora-user-images\image-20241228144451081.png)

![image-20241228144522021](C:\Users\29003\AppData\Roaming\Typora\typora-user-images\image-20241228144522021.png)

操作系统的作用

- 抽象
  - 逻辑地址空间
- 保护
  - 独立地址空间
- 共享
  - 访问相同内存
- 虚拟化
  - 更多的地址空间

### 地址空间&地址生成

物理地址空间——硬件支持的地址空间

逻辑地址空间——一个运行的程序所用的内存范围

![image-20241228145725123](C:\Users\29003\AppData\Roaming\Typora\typora-user-images\image-20241228145725123.png)

1. 当某个程序需要执行某条指令时ALU发出请求（带参数逻辑地址）
2. CPU去查找这个逻辑地址对应的物理地址
3. 找到了，CPU控制器向主存发出请求某个物理地址的内容
4. 主存通过总线，将内存的内容传递给CPU
5. CPU对指令进行执行

**操作系统起到对逻辑地址到物理地址映射的关系**

### 连续内存的分配

#### 内存的碎片问题

**外部碎片**：在分配单元间的未使用内存

**内部碎片**：再分配单元中的未使用内存

#### 分区的动态分配

**简单的内存管理方法**

1. 当一个程序准许运行在内存中时，分配一个连续的区间
2. 分配一个连续的内存区间给运行的程序以访问数据

**分配策略**

- 首次适配
  - 为了分配n字节，使用第一个可用空闲块移植块的尺寸比n大。
    - 按地址排序的空闲块列表
    - 分配需要寻找一个合适的分区
    - 重分配需要检查，看是否自由分区能和并与相邻的空闲分区
  - 优势
    - 简单
    - 易于产生更大的空闲块，向着地址空间的结尾
  - 劣势
    - 外部碎片
    - 不确定性
- 最有适配
  - 找到最有适配的空闲块，为了最小化外部碎片的尺寸
  - 优势
    - 当大部分分配是小尺寸时非常有效
    - 比较简单
  - 劣势
    - 外部碎片
    - 重分配慢
    - 易产生很多没用的微笑碎片
- 最差匹配分配
  - 找到空闲块差距最大的
    - 为了避免产生太多微笑碎片
  - 优势
    - 假如分配的是中等尺寸效果最好
  - 劣势
    - 重分配慢
    - 外部碎片
    - 易于破碎大的空闲块，以致大分区无法被分配

### 压缩式与交换式碎片整理

#### 压缩式碎片整理

**重置程序以合并孔洞**

**要求所有程序是动态可重置的**

#### 交换式碎片整理

交换式碎片整理的基本原理是通过将内存中的数据在内存和磁盘交换空间（通常是磁盘上的虚拟内存区域）之间进行交换，来重新排列内存中的数据，使得空闲内存空间能够尽可能地合并成较大的连续块，从而提高内存的利用率和分配效率。

### 非连续内存分配

- **优点**
  - 一个程序的物理地址空间是非连续的
  - 更好的内存利用和管理
  - 允许共享代码与数据（共享库等...）
  - 支持动态加载和动态连接
- **缺点**
  - 如何建立虚拟地址和物理地址之间的转换
    - 软件方案
    - 硬件方案
      - 分段
        - 程序的分段地址空间
          - ![image-20241228161319663](C:\Users\29003\AppData\Roaming\Typora\typora-user-images\image-20241228161319663.png)
        - 分段的寻址方案
      - 分页 

**分段**

- 一个段：一个内存“块”；
  - 一个逻辑地址空间
- 程序访问内存地址需要：
  - 一个二维的二元组（s,addr）
    - s——段号
    - addr——段内偏移

#### 段访问机制

![image-20250102114446723](C:\Users\Adminster\AppData\Roaming\Typora\typora-user-images\image-20250102114446723.png)

#### 分页机制

- 分页地址空间
- 页寻址方案

区别：段的尺寸不可变。

- 划分物理内存固定大小的帧
  - 大小是2的幂
- 划分逻辑地址空间至相同大小的页
  - 大小是2的幂
- 建立方案 转换逻辑地址为物理地址
  - 页表
  - MMU/TLB

![image-20250102115130040](C:\Users\Adminster\AppData\Roaming\Typora\typora-user-images\image-20250102115130040.png)

![image-20250102115450541](C:\Users\Adminster\AppData\Roaming\Typora\typora-user-images\image-20250102115450541.png)

- 页寻址机制
  - 页映射到帧
  - 页是连续的虚拟内存
  - 帧是非连续的物理内存
  - 不是所有的页都有对应的帧

#### 页表——概述、TLB

- 页表
  - 页表概述
    - 可以简单理解为逻辑地址进行运算后得到的索引简单映射出一个物理地址
    - 地址转换
      - 物理帧存在
      - 物理帧不存在
        - 内存在访问异常，由操作系统处理
  - 转换后备缓冲区
    - CPU中存在MMU（内存管理单元）其中含有Translation Look-aside Buffer (TLB)是一个Cache，TLB会缓存很多比较常用的页表项，通过相关寄存器进行并行查询，但是容量有限，它由一个key和一个value组成，当查到逻辑地址p时，可以查询TLB中是否存在，从而直接得到物理地址
    - 如果TLB中不存在，TLB Miss，就只能去查页表
  - 二级、多级页表
    - 将页表分为多级，页表的pagenumber分成多个
    - ![image-20250102165426212](C:\Users\Adminster\AppData\Roaming\Typora\typora-user-images\image-20250102165426212.png)
  - 反向页表

 有没有种方法，使得页表项和逻辑地址空间关系没那么大，而和物理地址空间关系会比较大

### 虚拟内存

**理想：更大、更快、更便宜的非易失性存储器** 

#### 覆盖技术

- 目标
  - 是在较小的可用内存中运行较大的程序。常用于多道程序系统，与分区存储管理配合使用。
- 原理：
  - 把程序按照其自身的逻辑结构，划分若干个功能上相对独立的程序模块，那些不会同时执行的模块共享同一块内存区域，按时间先后来运行。
    - 必要部分（常用功能）的代码和数据常驻内存；
    - 可选部分（不常用部分）在其他程序模块中实现，平时存在在外存中，在需要时调度进入内存
    - 不存在调用关系的模块不必同时装入内存，从而可以相互覆盖，即这些模块共用一个分区

一定要有一部分**常驻内存**来负责管理

- 缺点：
  - 由程序员来吧一个大的程序划分为若干个小的功能模块，并确定各个模块之间的覆盖关系，费时费力，增加了编程的复杂度
  - 覆盖模块从外存装入内存，实际上十一时间延长来换取空间节省。

#### 交换技术

- 目标：
  - 多道程序在内存中，让正在运行的程序或需要运行的程序获得更多的内存资源。
- 方法
  - 可将暂时不能运行的程序送到外存中，从而获得空闲内存空间
  - 操作系统把一个进程的整个地址空间的内容保存在外存中（换出 swap out）而将外存中的某个进程的地址空间读入到内存中（换入 swapin）。换入换出内容的大小为整个程序的地址空间。
- 问题
  - 交换时机的确定
  - 交换区的大小
  - 程序换入时的重定位

**覆盖与交换的比较**

- 覆盖只能发生在那些相互之间没有调用关系的程序模块之间，因此程序员必须给出程序内的各个模块之间的逻辑覆盖结构
- 交换技术是以在内存中的程序大小为单位来进行的，它不需要程序员给出各个模块之间的逻辑覆盖结构。换言之，交换发生在内存中程序与管理程序或操作系统之间，而覆盖则发生在运行程序的内部。

#### 虚拟内存管理技术

- 目标
  - 在内存不够用的情况下，可以采用覆盖技术和交换技术，但是覆盖技术需要程序员自己把整个程序划分为若干个小的功能块，并确定各个模块之间的覆盖关系，增加了程序员的负担；交换技术以进程作为交换的单位，需要把进程的整个地址空间都换进换出，增加了处理器的开销。
